<!DOCTYPE html>
<html lang="hu">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="../static/Palkotikumicon.png">

    <title>Programozási alapok</title>
    <link rel="stylesheet" href="../static/main.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  </head>
  <body>
    <header>
      <a href="../index.html"><img src="../static/Palkotikumlogo2.png" alt="p"></a>
      <h1>Programozási alapok</h1>
    </header>

    <main>
      <aside>
        <p><a href="../beginprog.html">Vissza</a></p>
        <nav>
          <ul>
            <li><a href="bevprog.html">Bevezetés a programozásba</a></li>
            <li><a href="progintro.html">Blokkprogramozás</a></li>
            <li><a href="alg.html">Adatszerkezetek és algoritmusok</a></li>
            <li><a href="#" id="aktiv">Programozási nyelvek</a></li>
            <li><a href="ada.html">Ada</a></li>
            <li><a href="c.html">C</a></li>
            <li><a href="cpp.html">C++</a></li>
            <li><a href="progkonyvek.html">Programozásról könyvek</a></li>
          </ul>
        </nav>
      </aside>
      <section>
        <p>Tartalom</p>
        <ul id="t">
          <li><a href="#mach">A gépi kód</a></li>
          <li><a href="#mikoze">Mi köze a programozási nyelvnek a gépi kódhoz?</a></li>
          <li><a href="#szintu">Alacsony szintű és magas szintű programozási nyelvek</a></li>
          <li><a href="#fk">A forráskód</a></li>
          <li><a href="#gen">A programozási nyelvek generációi</a></li>
          <li><a href="#psz">A pszeudokód</a></li>
          <li><a href="#szisze">Szintaxis és szemantika</a></li>
          <li><a href="#vid">További anyagok</a></li>
        </ul>

        <h1>Programozási nyelvek</h1>

        <p><a href="https://drive.google.com/file/d/1SQuVJWUn4sltv6By7M8nedIRBj8bzurD/view?usp=sharing" target=_blank>A programozási nyelvek története, fejlődése</a></p>

        <h1 id="mach">A gépi kód</h1>

        <p>A gépi kód a számítógépek központi feldolgozó egysége (CPU) által közvetlenül végrehajtható utasítások sorozata. Ez a legalacsonyabb szintű szoftveres réteg, amely közvetlenül vezérli a hardver működését. A gépi kód bináris számjegyekből (bitek, azaz 0 és 1) áll, amelyeket a CPU értelmez és hajt végre.</p>

        <h3>Jellemzői:</h3>
        <ol>
          <li><strong>Processzorspecifikus:</strong> Minden CPU saját gépi kód-készlettel rendelkezik, ami azt jelenti, hogy egy adott CPU-ra írt gépi kód nem feltétlenül fut más típusú CPU-kon.</li>
          <li><strong>Bináris formátum:</strong> A gépi kód általában bináris formában van, ahol minden egyes utasítás egy bináris számként van kódolva.</li>
          <li><strong>Nehéz emberi értelmezhetőség:</strong> Az emberek számára nehéz közvetlenül gépi kódban programozni vagy olvasni, mivel a bináris számokból álló utasításokat nehéz megérteni.</li>
        </ol>

        <h3>Példa:</h3>
        <p>Egy egyszerű gépi kódú utasítás egy Intel x86 processzorra például így nézhet ki: <strong>10110000 01100001</strong></p>
        <p>Ebben a példában az első része a "10110000" az utasításkódot jelöli, amely lehet például egy "MOV" utasítás, ami egy adatot tölt be egy regiszterbe. A "01100001" rész pedig az adatot tartalmazza, amit be kell tölteni.</p>

        <h3>Fordítás magasabb szintű nyelvekből:</h3>
        <p>A programozók általában magasabb szintű programozási nyelveken, mint például C, Java, vagy Python írnak kódot, amelyet egy fordítóprogram (compiler) vagy értelmező (interpreter) alakít át gépi kóddá, hogy a CPU végre tudja hajtani. Az Assembly nyelv például már közelebb áll a gépi kódhoz, de még mindig ember által értelmezhetőbb.</p>
        <p>Összességében a gépi kód az a forma, amelyben egy program közvetlenül kommunikál a számítógép hardverével.</p>

        <h1 id="mikoze">Mi köze a programozási nyelvnek a gépi kódhoz?</h1>

        <p>A programozási nyelvek és a gépi kód közötti kapcsolat szoros, mivel a programozási nyelvek fő célja, hogy lehetővé tegyék a fejlesztők számára a számítógépek irányítását anélkül, hogy közvetlenül gépi kódban kellene írniuk a programokat.</p>

        <h3>Magas szintű programozási nyelvek:</h3>
        <p>A programozók általában magas szintű programozási nyelveket használnak, mint például C, Java, Python, vagy C++. Ezek a nyelvek emberbarát szintaxissal rendelkeznek, és lehetővé teszik komplex programok egyszerűbb megírását.</p>
        <p>Ezek a nyelvek olyan absztrakciókat kínálnak, mint változók, függvények, ciklusok, feltételes utasítások, amelyek megkönnyítik a fejlesztők munkáját. Ezeket a nyelveket nem lehet közvetlenül a CPU-n végrehajtani, mert a CPU csak gépi kódot ért.</p>

        <h3>Fordítás (kompilálás) vagy értelmezés (interpretálás):</h3>
        <p>Ahhoz, hogy a magas szintű programozási nyelven írt kódot a számítógép végrehajtsa, azt először gépi kódra kell fordítani. Ez a fordítás történhet kétféleképpen:</p>
        <ul>
          <li><strong>Fordítás:</strong> A fordítóprogram (compiler) a magas szintű kódot lefordítja gépi kódra, amit a CPU közvetlenül végrehajthat. Például a C programnyelvnél egy C fordító a C forráskódot gépi kódú futtatható állománnyá (például egy .exe fájllá) alakítja.</li>
          <li><strong>Értelmezés:</strong> Az értelmezőprogram (interpreter) a magas szintű kódot soronként értelmezi és hajtja végre, de általában nem készít közvetlen gépi kódú futtatható állományt. Például a Python egy interpretált nyelv, ahol a Python interpreter soronként hajtja végre a kódot, miközben az utasításokat gépi kódra fordítja a futás során.</li>
        </ul>

        <h3>Assembly nyelv:</h3>
        <p>Az Assembly nyelv a gépi kód ember által olvashatóbb formája. Bár még mindig alacsony szintű nyelv, az Assembly utasítások közvetlenül megfelelnek a gépi kód utasításainak, de emberi nyelven (szimbólumokkal) vannak kifejezve. A fordítóprogram (assembler) ezt a kódot alakítja át gépi kóddá.</p>

        <h3>Összefoglalva:</h3>
        <p>A programozási nyelvek lehetővé teszik a fejlesztők számára, hogy ember számára érthetőbb módon írjanak programokat.</p>
        <p>A magas szintű kódot a fordító vagy értelmező program alakítja át gépi kóddá, amit a számítógép közvetlenül végrehajthat.</p>
        <p>Az Assembly nyelv egy alacsony szintű nyelv, amely szorosabban kapcsolódik a gépi kódhoz, de még mindig egy lépcsőfokkal magasabb szinten áll a közvetlen bináris utasításoknál.</p>

        <h1 id="szintu">Alacsony szintű és magas szintű programozási nyelvek</h1>

        <h3>Alacsony szintű programozási nyelv</h3>
        <p>Az alacsony szintű programozási nyelvek közel állnak a számítógép hardveréhez, és közvetlen hozzáférést biztosítanak a memória és a processzor működéséhez. Ezek a nyelvek nagyon hatékonyak, mivel minimális absztrakcióval rendelkeznek, és a hardver specifikus utasításokkal dolgoznak. Az alacsony szintű nyelvek közé tartozik a gépi kód és az Assembly nyelv.</p>

        <p><strong>Jellemzői:</strong></p>
        <ul>
          <li><strong>Magas teljesítmény:</strong> Mivel közvetlen hozzáférést biztosítanak a hardverhez, az alacsony szintű nyelvek lehetővé teszik a nagyon gyors és hatékony kódok írását.</li>
          <li><strong>Nehézségi szint:</strong> Az alacsony szintű nyelvek programozása bonyolultabb és időigényesebb, mivel a programozónak részletesen kell ismernie a hardver működését.</li>
          <li><strong>Portabilitás:</strong> Az alacsony szintű nyelvek által írt programok általában nem hordozhatóak egyik gépről a másikra, mivel a kód specifikus egy adott hardverarchitektúrához.</li>
        </ul>

        <h3>Magas szintű programozási nyelv</h3>
        <p>A magas szintű programozási nyelvek olyan absztrakciókat biztosítanak, amelyek elrejtik a hardver részleteit, és lehetővé teszik a programozók számára, hogy könnyebben írjanak kódot. Ezek a nyelvek közelebb állnak a természetes nyelvhez, és könnyebb őket megtanulni és használni. A magas szintű nyelvek közé tartozik például a Python, Java, és C++.</p>

        <p><strong>Jellemzői:</strong></p>
        <ul>
          <li><strong>Könnyű használat:</strong> A magas szintű nyelvek egyszerűbb szintaxissal rendelkeznek, ami megkönnyíti a kódolást és az olvasást.</li>
          <li><strong>Portabilitás:</strong> A magas szintű nyelvekkel írt programok általában hordozhatóak, és különböző platformokon is futtathatók, mivel a fordítók vagy értelmezők elvégzik a gépi kódra való fordítást.</li>
          <li><strong>Kevésbé hatékony:</strong> A magas szintű nyelvek általában kevésbé hatékonyak, mint az alacsony szintűek, mivel a hardverhez való közvetlen hozzáférés hiányzik, és több réteg absztrakciót használnak.</li>
        </ul>

        <h1 id="fk">A forráskód</h1>

        <p>A forráskód egy számítógépes program vagy alkalmazás írott változata, amelyet egy programozási nyelv segítségével hoztak létre. A forráskódot általában emberi programozók írják és olvassák, és olyan szöveges formátumban van, amelyet speciális szerkesztőkben (például szövegszerkesztőkben vagy integrált fejlesztőkörnyezetekben, azaz IDE-kben) lehet szerkeszteni.</p>

        <p>A forráskód:</p>
        <ol>
          <li><strong>A program logikáját és működését határozza meg:</strong> A forráskódban leírt utasítások határozzák meg, hogyan működik a program, milyen feladatokat hajt végre, és hogyan reagál a különböző eseményekre vagy felhasználói interakciókra.</li>
          <li><strong>Fordítás vagy értelmezés szükséges:</strong> A forráskódot általában nem lehet közvetlenül futtatni a számítógépen. A forráskódot le kell fordítani gépi kódra (amit a számítógép processzora közvetlenül ért) egy fordítóprogram (compiler) segítségével, vagy értelmezni kell egy interpreter segítségével, amely lépésről lépésre végrehajtja az utasításokat.</li>
          <li><strong>Emberi olvashatóságú:</strong> A forráskódot olyan nyelven írják, amelyet programozók könnyen megértenek. Ez magában foglalhatja az angol nyelvű szavakat, szintaktikai szabályokat, és különböző struktúrákat (például ciklusokat, feltételes utasításokat).</li>
        </ol>

        <p>Például a következő sor egy egyszerű Python forráskód, amely kiírja a "Hello, World!" üzenetet:</p>

        <code>print("Hello, World!")</code>

        <p>A forráskód tehát az alapja minden szoftvernek, és elengedhetetlen a programok fejlesztéséhez, karbantartásához és módosításához.</p>

        <h1 id="gen">A programozási nyelvek generációi</h1>
        <p>A programozási nyelveket történelmük és fejlettségük alapján generációkba soroljuk. Minden generáció újabb absztrakciós szintet hozott a programozásba, megkönnyítve ezzel a kódírást és a programok karbantartását.</p>

        <h3>Első generáció (1GL): Gépi nyelv</h3>
        <p>Az első generációs nyelvek a gépi nyelvet jelentik, amely a számítógép központi feldolgozó egysége (CPU) által közvetlenül végrehajtható bináris kódot tartalmazza. Ezek a nyelvek hardverközeli és nagyon hatékonyak, de rendkívül nehezen programozhatók és karbantarthatók.</p>

        <h3>Második generáció (2GL): Assembly nyelv</h3>
        <p>A második generációs nyelvek az Assembly nyelvet foglalják magukba, amely az első generációs gépi kód ember által olvashatóbb formája. Az Assembly nyelv egy-egy utasítása közvetlenül megfelel egy gépi kódú utasításnak, de szimbólumokkal dolgozik, ami megkönnyíti a programozást.</p>

        <h3>Harmadik generáció (3GL): Magas szintű nyelvek</h3>
        <p>A harmadik generációs nyelvek már magas szintű programozási nyelvek, mint például a C, C++, Java, és Python. Ezek a nyelvek sokkal közelebb állnak a természetes nyelvhez, és számos absztrakciós réteget kínálnak, amelyek elrejtik a hardver részleteit. Ez megkönnyíti a programozást és a kód karbantartását, ugyanakkor a program fordításra szorul, hogy gépi kódra alakítsák át.</p>

        <h3>Negyedik generáció (4GL): Magasabb szintű nyelvek</h3>
        <p>A negyedik generációs nyelvek még magasabb szintűek, és általában egy adott célra vagy feladatra specializálódtak. Ide tartoznak az adatbázis-kezelő nyelvek, mint például az SQL, valamint a riport- és lekérdezéskezelő nyelvek. Ezek a nyelvek lehetővé teszik a bonyolult feladatok egyszerűbb megfogalmazását.</p>

        <h3>Ötödik generáció (5GL): Logikai és mesterséges intelligencia nyelvek</h3>
        <p>Az ötödik generációs nyelvek közé tartoznak azok a nyelvek, amelyeket a mesterséges intelligencia (MI) és a logikai programozás területén használnak, mint például a Prolog és a Lisp. Ezek a nyelvek lehetővé teszik a gépi tanulás, az automatizált következtetések és a logikai érvelés megvalósítását.</p>

        <h1 id="psz">A pszeudokód</h1>

        <p>A pszeudokód egy olyan, félformális kódleíró nyelv, amelyet arra használnak, hogy algoritmusokat és programok logikáját emberi érthetőségű módon leírják. A pszeudokód nem követi egy konkrét programozási nyelv szintaxisát, hanem egyszerű, hétköznapi nyelvi kifejezéseket használ, amelyeket könnyen megérthetnek mind a programozók, mind a nem programozók.</p>

        <h3>Jellemzői:</h3>

        <ol>
          <li><strong>Egyszerűség:</strong> A pszeudokód mentes a konkrét programozási nyelvek szintaktikai szabályaitól. Az írása során a hangsúly a logikán és az algoritmus megértésén van, nem pedig a pontos nyelvi szintaxison.</li>
          <li><strong>Közérthetőség:</strong> A pszeudokód célja, hogy a programozásban kevésbé jártas emberek is megértsék az algoritmus működését. Emiatt gyakran használ közérthető szavakat, mint például "HA", "KÜLÖNBEN", "ISMÉTELD", "ADDIG AMÍG", stb.</li>
          <li><strong>Nyelvfüggetlenség:</strong> Mivel a pszeudokód nem követi egy konkrét programozási nyelv szabályait, bármilyen nyelvre lefordítható. Ez lehetővé teszi, hogy a tervezés során ne kelljen egy konkrét nyelvhez ragaszkodni.</li>
          <li><strong>Strukturáltság:</strong> Bár nincs szigorú szintaxisa, a pszeudokód általában strukturált formát követ, ami tükrözi az algoritmus lépéseit: a feltételes utasítások, ciklusok és változók világosan megjelennek benne.</li>
        </ol>

        <h3>Példa pszeudokódra:</h3>
        <p>Tegyük fel, hogy egy algoritmust szeretnénk leírni, amely meghatározza, hogy egy szám pozitív, negatív vagy nulla.</p>

<pre><code>
HA a szám &gt; 0 AKKOR
  ÍRD KI "A szám pozitív"
KÜLÖNBEN HA a szám &lt; 0 AKKOR
  ÍRD KI "A szám negatív"
KÜLÖNBEN
  ÍRD KI "A szám nulla"
</code></pre>

        <p>Ebben a példában:</p>
        <ul>
          <li>A "HA", "AKKOR", "KÜLÖNBEN" kifejezések logikai döntéshozatalt jelölnek.</li>
          <li>A "ÍRD KI" egy egyszerű kimeneti utasítás, amely utasítja a programot, hogy jelenítse meg az adott szöveget.</li>
        </ul>

        <h3>Mire használják a pszeudokódot?</h3>
        <ul>
          <li><strong>Algoritmusok tervezése:</strong> A programozók és mérnökök gyakran használnak pszeudokódot, hogy a programok vagy rendszerek logikáját részletesen megtervezzék, mielőtt konkrét kódot írnának.</li>
          <li><strong>Oktatás:</strong> A pszeudokódot gyakran használják az algoritmusok és programozási koncepciók oktatásában, mivel segít a diákoknak az alapvető logikai lépések megértésében anélkül, hogy egy adott programozási nyelv szintaktikai bonyodalmaival kellene megküzdeniük.</li>
          <li><strong>Kommunikáció:</strong> A pszeudokódot használhatják különböző szerepkörökben dolgozó szakemberek (például fejlesztők és tervezők) közötti kommunikációra, hogy világosan bemutassák az algoritmusokat és a program logikáját.</li>
        </ul>

        <p>Összefoglalva, a pszeudokód egy hasznos eszköz az algoritmusok megértéséhez és tervezéséhez, amely hidat képez a programozás logikája és a konkrét kódolási folyamat között.</p>

        <h1 id="szisze">Szintaxis és szemantika</h1>

        <p>A <strong>szintaxis</strong> és a <strong>szemantika</strong> két alapvető fogalom a programozásban és a nyelvészetben, amelyek a nyelv szerkezetére és jelentésére vonatkoznak.</p>

        <h3>Szintaxis</h3>
        <p>A szintaxis a szabályok rendszere, amely meghatározza, hogyan kell helyesen megírni a programok vagy nyelvi kifejezések szerkezetét. Más szóval, a szintaxis azt írja le, hogy milyen sorrendben és milyen formában kell a programozási nyelv elemeit (például kulcsszavak, operátorok, változók) elrendezni ahhoz, hogy a kód érvényes legyen.</p>

        <h3>Példák a szintaxisra:</h3>
        <ul>
          <li>
            <p><strong>Programozásban:</strong> Egy egyszerű példa a Pythonban egy változó értékadására:</p>
            <p><code>x = 10</code></p>
            <p>Itt a szintaxis szabálya az, hogy egy változónév, amely egyenlőségjellel kapcsolódik egy értékhez, érvényes szintaktikai szerkezet.</p>
          </li>
          <li>
            <p><strong>Szintaktikai hiba:</strong> Ha például elfelejted a kettőspontot egy Python <code>if</code> utasítás végén:</p>
            <p><code>if x &gt; 5<br>
            print("X is greater than 5")</code></p>
            <p>Ez szintaktikai hiba, mert a Pythonban az <code>if</code> utasítást kettőspontnak kell követnie.</p>
          </li>
        </ul>

        <h3>Szemantika</h3>
        <p>A szemantika viszont a nyelv vagy kód jelentésére, értelmezésére utal. A szemantika azt írja le, hogy a program milyen viselkedést eredményez vagy milyen hatást fejt ki, amikor helyes szintaxissal írt kódot hajtunk végre. A szemantika tehát arra vonatkozik, hogy mit <strong>jelent</strong> a helyes kód, és milyen eredményt várhatunk tőle.</p>

        <h3>Példák a szemantikára:</h3>
        <ul>
          <li>
            <p><strong>Programozásban:</strong> Vegyük a következő Python kódot:</p>
            <p><code>x = 5<br>
            y = x + 3<br>
            print(y)</code></p>
            <p>A szintaxis helyes, és a szemantika szerint ez a kód 8-at ír ki, mert az <code>x</code> értéke 5, és a <code>y</code> értéke 8 lesz az összeadás után.</p>
          </li>
          <li>
            <p><strong>Szemantikai hiba:</strong> Tegyük fel, hogy egy programozó elfelejtette, hogy egy változó nulla lehet, és egy kódot írt, ami egy változóval oszt:</p>
            <p><code>z = 10 / x</code></p>
            <p>Ha <code>x</code> értéke nulla, a kód szintaxisa helyes lehet, de a futtatás során szemantikai hiba történik (például <code>ZeroDivisionError</code> a Pythonban), mivel az osztás nullával nem értelmezhető.</p>
          </li>
        </ul>

        <h3>Összefoglalva:</h3>
        <ol>
          <li><strong>Szintaxis:</strong> A nyelv formája, szabályai és szerkezete. Ez határozza meg, hogy hogyan kell helyesen írni a kódot.</li>
          <li><strong>Szemantika:</strong> A nyelv vagy kód jelentése. Ez határozza meg, hogy a helyes szintaxissal írt kód milyen viselkedést vagy eredményt eredményez.</li>
        </ol>

        <h1 id="vid">További anyagok</h1>

        <h3>Programozás Karrier - Programozási nyelvek</h3>
        <p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Ty5gqryG0J8?si=RCdLNF7c6mokk9GZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></p>

        <h3>KódKurzus - Programozási nyelvek (#13 Programozás Tutorial)</h3>
        <p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/NqeDosHNmdg?si=RXdTUeuGIBaCJiJQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></p>

        <h3>Az informatika számítástudományi alapjai</h3>
        <p>A formális nyelvek és automaták elméletének alapjai. Nyelvműveletek, generatív nyelvtanok, generált nyelvek. Nyelvosztályok, a Chomsky-hierarchia. Reguláris nyelvtanok, nyelvek és kifejezések, zártsági tulajdonságok. Nemdeterminisztikus és determinisztikus véges automaták, lineáris idejű felismerés. Veremautomaták, polinom idejű felismerés, Chomsky-féle normálforma, a CYK és az Early algoritmus. Determinisztikus környezetfüggetlen nyelvek, LL(k) és LR(k) elemzők, fordítóprogramok, interpreterek. Determinisztikus Turing-gépek, algoritmusleíró eszközök. Lineárisan korlátozott automaták, monoton és környezetfüggő nyelvtanok. Eldönthetetlen problémák, tár és idő korlátok. Nemdeterminisztikus Turing-gépek, nevezetes nyelvosztályok, P, NP.</p>

        <h3>Ésik Zoltán: A számítástudomány alapjai</h3>
        <p><a href="https://drive.google.com/file/d/1ca5GORiendjm8239d0fY5SVDN8sEgtbp/view?usp=sharing" target=_blank>1. Véges automaták és reguláris nyelvek</a></p>
        <p><a href="https://drive.google.com/file/d/1x4pMdzidVvwempQvQsJIcMR6mPzeqmhQ/view?usp=sharing" target=_blank>2. Környezetfüggetlen nyelvek és veremautomaták</a></p>
        <p><a href="https://drive.google.com/file/d/1qqVhQMUSjpcKcPaOnQcXyRBgQSC2-5II/view?usp=sharing" target=_blank>3. A Chomsky-féle hierarchia</a></p>
        <p><a href="https://drive.google.com/file/d/1Oma1yHp2kpKnX7QLPRkff4WW2_0KMCC6/view?usp=sharing" target=_blank>4. Kiszámíthatóságelmélet</a></p>
        <p><a href="https://drive.google.com/file/d/1cvFC1t-zvZ-NFxntuh6x123lfaQFvpDZ/view?usp=sharing" target=_blank>5. Bonyolultságelmélet</a></p>

        <h3>Magas szintű programozási nyelvek 1</h3>
        <p>A magas szintű programozási nyelvek kialakulása és osztályozása. Programozási paradigmákról. Szintaxisleíró formális eszközök. Karakterkészlet. Lexikális egységek (elhatároló, szimbolikus nevek, címke, megjegyzés, literálok). A forrásszöveg összeállításának szabályai, a szóköz szerepe. Adattípusok. Nevesített konstans. A változó. Kifejezések, operandusok és operátorok, precedenciatáblázat. Deklarációs utasítások. Végrehajtó utasítások. Értékadó, üres és ugró utasítás. Két- és többirányú elágaztatás. Ciklusszervező utasítások, ciklusfajták és alkalmazásaik. Vezérlő utasítások. Programegységek. Alprogramok (eljárás, függvény). Hívási lánc, rekurzió. A futtató rendszer szolgáltatásai. Paraméterkiértékelés, paraméterátadás. Blokk. Hatáskörkezelés, láthatóság. Fordítási egység. Absztrakt adattípus. Generikus programozás. A programnyelvek I/O eszközei, állománykezelés. A kivételkezelés alapfogalmai, kivételkezelési módszerek és eszközrendszerek. A párhuzamos programozás fogalmai.</p>
        <p>A funkcionális programozási paradigma alapjai. A funkcionális programozási paradigma előnyei és hátrányai az imperatív programozási paradigmával szemben. A függvényhívások kiértékelésének szemantikája (lista, mohó) és a funkcionális programok értelmezése. Funkcionális nyelvi elemek. Függvények mint értékek. Magasabbrendű függvények.</p>
        <p>Bevezető példák, egyszerű C programok írása. Konstansok és változók használata, adatbevitel, adatok megjelenítése a standard kimeneten. A változó és a memória kapcsolata. Elemi aritmetikai műveletek egész és valós számokkal. Nevesített konstansok használata. A sizeof operátor. Explicit típuskonverzió. További numerikus típusok. Az op= alakú értékadás. Matematikai függvények. Két- és többirányú elágaztató utasítások. Ciklusutasítások (for, while, do-while). Tömbök. Az & operátor. Sztringek. Mutatók. Mutatók és tömbök kapcsolata. Többdimenziós tömbök. Dinamikus memóriafoglalás. A program felépítése, saját függvények írása. Függvénymutatók. Rekurzív függvények. A standard bemenetet és a standard kimenetet kezelő függvények. Struktúrák. Műveletek állományokkal. Az előfeldolgozó rendszer. Nyomkövetést és hibakeresést támogató nyelvi eszközök. C++ nyelvi elemek és programozási eszközök.</p>

        <h3>Magas szintű programozási nyelvek 1</h3>
        <p><a href="https://drive.google.com/file/d/1eWYOk8qinrmP-zJTnniuG7oraBQ9os1D/view?usp=sharing" target=_blank>1. Bevezetés</a></p>
        <p><a href="https://drive.google.com/file/d/1p48U69C4ilCervQbPOnq09aYUh6059YI/view?usp=sharing" target=_blank>2. Alapelemek</a></p>
        <p><a href="https://drive.google.com/file/d/1F0IvL-nS1_AgSp_5bPXQUM87iA6e1DuP/view?usp=sharing" target=_blank>3. Kifejezések</a></p>
        <p><a href="https://drive.google.com/file/d/1hhT7iiW9hbwBzlRMLHKOVEbQTSDejL2Q/view?usp=sharing" target=_blank>4. Utasítások</a></p>
        <p><a href="https://drive.google.com/file/d/1N9ECUPkolyg6XjTb-REsBgkB83VYhWJi/view?usp=sharing" target=_blank>5. A programok szerkezete</a></p>
        <p><a href="https://drive.google.com/file/d/15yW-NA1KaU1tSFeGDndPD4glVYBrtNIn/view?usp=sharing" target=_blank>6. Absztrakt adattípus</a></p>
        <p><a href="https://drive.google.com/file/d/1qvpCVXf4RxJlGe-yvpupCZf0wG_naML7/view?usp=sharing" target=_blank>7. A csomag</a></p>
        <p><a href="https://drive.google.com/file/d/16kOEFo58dl7cRC8XTb4WjCD4m8KFn9XR/view?usp=sharing" target=_blank>8. Az Ada fordításról</a></p>
        <p><a href="https://drive.google.com/file/d/1W2qHwnQIU80c4a-sFhrYPtY5i5b5z1cz/view?usp=sharing" target=_blank>9. Kivételkezelés</a></p>
        <p><a href="https://drive.google.com/file/d/160gxi4Cc8HilS-j8hIoc4hDqfLnnDP2B/view?usp=sharing" target=_blank>10. Generikus programozás</a></p>
        <p><a href="https://drive.google.com/file/d/1tEJIBgst5LgKAly1bOYL6U54mPP7nS4C/view?usp=sharing" target=_blank>11. Párhuzamos programozás</a></p>
        <p><a href="https://drive.google.com/file/d/10x47Sb1xDhVgAl7K2IxRpvIv4vA9wUc0/view?usp=sharing" target=_blank>12. A taszk</a></p>

        <h3>Magas szintű programozási nyelvek 2</h3>
        <p>Az objektumorientált paradigma alapfogalmai. Osztály, objektum, példányosítás. Öröklődés, osztályhierarchia. Polimorfizmus, metódustúlterhelés. Hatáskörkezelés. A bezárási eszközrendszer, láthatósági szintek. Absztrakt osztályok és interfészek. Modellező eszközök és nyelvek. Az UML és az UML osztálydiagramja. Objektumorientált programozási nyelvek programnyelvi elemei: karakterkészlet, lexikális egységek, kifejezések, utasítások. Objektumorientált programozási nyelvek típusrendszere (pl.: Java, C#). Típusok tagjai: mezők, (nevesített) konstansok, tulajdonságok, metódusok, események, operátorok, indexelők, konstruktorok, destruktorok, beágyazott típusok. Interfészek. Kollekciók. Funkcionális nyelvi elemek. Lambda kifejezések. Adatfolyamok kezelése, streamek. Kivételkezelés, I/O, állománykezelés. Szerializáció. Reflexió. A fordítást és a kódgenerálást támogató nyelvi elemek (annotációk, attribútumok). Multiparadigmás nyelvek. Programozás multiparadigmás nyelveken.</p>

        <h3>Magas szintű programozási nyelvek 2</h3>
        <p><a href="https://drive.google.com/file/d/1kG_EutVLiQjWLUVrTnmZ83KBhaEp9lpq/view?usp=sharing" target=_blank>2. Objektumorientáltság</a></p>
        <p><a href="https://drive.google.com/file/d/1YrnRuc2p-TVwYuiBGtQUnC-3Oz9T11aq/view?usp=sharing" target=_blank>3. Java</a></p>
        <p><a href="https://drive.google.com/file/d/15GxPX_JufvGMNm5IBCRmXNcS9g7WWfNv/view?usp=sharing" target=_blank>4. Eiffel</a></p>
        <p><a href="https://drive.google.com/file/d/13kLthSueAu-rf0CXek7_Xefw6U59K-7x/view?usp=sharing" target=_blank>5. Smalltalk</a></p>
        <p><a href="https://drive.google.com/file/d/1h9lw4beX7USEX67QKGSHB1SxJf5DncmJ/view?usp=sharing" target=_blank>6. A funkcionális paradigma</a></p>
        <p><a href="https://drive.google.com/file/d/1khC0gUy9f3nSKO-iWKRpZyabvHSeEgsJ/view?usp=sharing" target=_blank>7. LISP</a></p>
        <p><a href="https://drive.google.com/file/d/12uuOHMZzkPIAnTzqQQM_F5pHclNw6Upb/view?usp=sharing" target=_blank>8. Logikai nyelvek: Prolog</a></p>
        <p><a href="https://drive.google.com/file/d/12xqSGKaI9f7m2OHlvF0K152ivDLg1xk4/view?usp=sharing" target=_blank>9. Adatfolyam nyelvek</a></p>

        <h3>Fordítóprogramok</h3>
        <p>Fordítóprogramok szerkezete, reader és extender szerepe, nyelvtanok, elemzők, elemzési fa, szakterület-specifikus nyelvek (DSL), forrás-forrás fordító, interpreter.</p>

        <h3>Concept of programming languages</h3>
        <p><a href="https://drive.google.com/file/d/1HahrULcG3uYwzE8vbHYM0LkXPi7Dvm6S/view?usp=sharing" target=_blank>Preface</a></p>
        <p><a href="https://drive.google.com/file/d/1iWZ8iXTkWVfwOwp68uKZJIy4n1yfRICs/view?usp=sharing" target=_blank>1. Preliminaries</a></p>
        <p><a href="https://drive.google.com/file/d/1FGIoZwSlywMdCQ4HNtXD1XRJqHexKXXY/view?usp=sharing" target=_blank>2. Evolution of the major programming languages</a></p>
        <p><a href="https://drive.google.com/file/d/1DpZNKKyv3wtogVgOlSAx4zIv1pLqIgNl/view?usp=sharing" target=_blank>3. Describing syntax and semantics</a></p>
        <p><a href="https://drive.google.com/file/d/1kpWSArXlwPDtrp8OMml-f6ZGB1KMWxov/view?usp=sharing" target=_blank>4. Lexical and syntax analysis</a></p>
        <p><a href="https://drive.google.com/file/d/16dxV2D848WzwQL3yA9AIVnGYNX3PQUtf/view?usp=sharing" target=_blank>5. Names, bindings, and scopes</a></p>
        <p><a href="https://drive.google.com/file/d/1NYrGp_XbDZhb0xvZHGBCE8afDE0sjJa5/view?usp=sharing" target=_blank>6. Data types</a></p>
        <p><a href="https://drive.google.com/file/d/1GMF76FusCJqaK3_Xmmku9InCn_HUzOV6/view?usp=sharing" target=_blank>7. Expressions and assignment statements</a></p>
        <p><a href="https://drive.google.com/file/d/1-tTMa9h2xfcorCmG1cR8v7liDK8H81Hh/view?usp=sharing" target=_blank>8. Statement-level control structures</a></p>
        <p><a href="https://drive.google.com/file/d/1gIlpTQY96ywMoX1nNJS5v05Gx2ds7b57/view?usp=sharing" target=_blank>9. Subprograms</a></p>
        <p><a href="https://drive.google.com/file/d/1vfgq6vmDXP7_yR6wWW9TG36MpX2zgDCU/view?usp=sharing" target=_blank>10. Implementing subprograms</a></p>
        <p><a href="https://drive.google.com/file/d/13Rdtdar3WCJNRmRXAtzu3INsjUfsu0yc/view?usp=sharing" target=_blank>11. Abstract data types and encapsulation constructs</a></p>
        <p><a href="https://drive.google.com/file/d/1soujQtV8sKs1Pbd8xVoVRUny759lfRiC/view?usp=sharing" target=_blank>12. Support for object-oriented programming</a></p>
        <p><a href="https://drive.google.com/file/d/1qVpLUktgQPq08HNnH-HgdVjHVIXz_uJN/view?usp=sharing" target=_blank>13. Concurrency</a></p>
        <p><a href="https://drive.google.com/file/d/1LAPLglA1cWrZlvffnnFSjibhrJ5VfDLC/view?usp=sharing" target=_blank>14. Exception handling and event handling</a></p>
        <p><a href="https://drive.google.com/file/d/1NbNrDu_P8vDB_9mkNRTwbNCLkI6vA6Rg/view?usp=sharing" target=_blank>15. Functional programming languages</a></p>
        <p><a href="https://drive.google.com/file/d/1aErF9L-gV53UgCCQ3a8g4pobJhZFERBq/view?usp=sharing" target=_blank>16. Logic programming languages</a></p>
        <p><a href="https://drive.google.com/file/d/1afo-FSkR0bTBEQAapuzxwZpYZX9NbpP_/view?usp=sharing" target=_blank>Bibliography</a></p>
      </section>
    </main>
    <footer>
      <p>Csak az önálló tanulás bír tartós értékkel. &#x2022; <a href="https://www.demokratikusneveles.hu/blog/gatto-miert-nem-oktatnak/" target="_blank">John Taylor Gatto</a></p>
      <img src="../static/cc.logo.large.png" alt="cc">
    </footer>
  </body>
</html>